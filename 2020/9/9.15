1. 读了一下昨天文章作者在邮件中提到的文章，但发现内容是同态加密的，但是里面关于浮点数的处理也不是我需要的。
   
   然后自己写了一个，就是将浮点数f先进行放大，即f=f*1e18，然后随机生成k-1个数s1,s2,...,sk-1，接着用浮点
   数f减去这k-1个数得sk = f-s1-s2-,...,sk-1，这样将sk自己保存，将s1到sk-1发给其他参与者。

   按理说这里将浮点数放大后应该转换成整数，然后在GF(q)下进行运算，但那样代码实现会非常麻烦，因为要先把
   pytorch中的tensor变量转换为numpy中的ndarry，再将ndarry中数据转换int，处理完还有逐个转换回去。
   所以这里我就直接随机生成k-1个值，然后用浮点数逐个相减了。不过这里可能还会修改，在论文里具体是用伪随机数
   还是用多项式来实现还没想好，不过这个并不影响结果。